# Project C2: SHELL
#### Members of the group: 
- Julian Neubert (S288423)
- Pablo Andres Vejar Gomez (S291761)

#### Date of delivery: 31/01/2022

## Project Summary
The main purpose of this project is to support running multiple processes at once from actual compiled programs stored on disk. These programs will be loaded into OS161 and executed in user mode, under the control of your kernel and the command shell in bin/sh (menu command: p bin/sh). 
In order to achieve this, as a team, we implemented several system calls to support process and open file management inside our kernel. This also required the creation and management of new data structures to store information about the system process state.
We added the `OPT_SHELL` option to neatly encapsulate any additions made to the codebase of OS161 during the implementation of our project. This way OS161 can easily be reverted to it's original state and run without the process and file syscall implemented. Two files are being optionally included based on the value of `OPT_SHELL`.
`file_syscalls.c` contains the main part of the code to support all file-related system calls. Its header file, `file_syscalls.h`, additionally defines a struct `fhandle`, which stores information related to open files that are being used by a process. A big part of our implementation of these system calls is to make sure that any change of information is correctly reflected in the state managing structures. Most of the actual interaction with the file system is handled by another abstraction layer defined in `vfs.h`. If all information required to interact with a file has been properly saved, the logic of these system calls is pretty straight forward. One important thing to note is that each system call will carefully need to verify any user supplied arguments and move data between user and kernel spaces in a safe way.
All of the process management related system calls are implemented in `proc_syscalls.c`. [more][synch?]

## File System Calls
The file system calls can be divided into several categories. Most are related to interacting with files, such as `open`, `dup2`, `close`, `read`, `write`, and `lseek`. The remaining two, `__getcwd` and `chdir`, are instead used to read and manipulate the current working directory.
The CWD is defined per-process and describes the location in the file system from which a process operates. This dictates for example the relative paths of other files to the process. It is stored as a `vnode` struct in the `proc` struct. `__getcwd` can be used to read it and `chdir` can set it to a new directory.
If a process is interacting with a file, then the 
If a process wants to access a file, it can not do so directly, but it must first open that file by calling the `open` system call. This system call returns an integer, the file descriptor, to the calling process. Now whenever the process wants to perform an action on this file, it can identify the file to the kernel using the file descriptor. This file descriptor can be duplicated using the `dup2` system call, and closed with the `close` system call, ending the interaction.
Internally the file descriptor points to a file handle, a `fhandle` struct. File handles track meta data about a process interacting with a file. It contains information directly related to the interaction, such as the `vnode` describing the file, the current offset into the file, and access permissions in the form of flags. But it also also holds information related to ensuring proper management, such as a lock to synchronize file access and a reference counter to know, when the file interaction has ended.
All file handles associated with a process are stored in the file table, an array of `fhandle`s called `p_fdtable` that is stored in the `proc` struct. Usually file handles are modified implicitly such as during syscalls `read` or `write`, to keep their state up to date. But they can also be changed explicitly with syscalls such as `lseek` or `dup2`.
Lastly there are a few special file descriptors, which have a special meaning by convention. The first three entries of the file table correspond to stdin, stdout and stderr and are generally available to a process without specifically having to open them. To achieve this we open them in the first user process that is being created and pass them down to other processes in the fork system call. This is achieved in the `runprogram` function.

## Process System Calls

## Testing
Since OS161 has a huge library of user programs we decided to try and keep things as simple as possible by utilizing this library as much as possible. Many of these programs represent very simple programs that could be actually used by an end user. They are thus complex end to end tests that often call several different syscalls and usually only provide valid parameters. In this section we discuss how we choose a subset of this testing library to verify the correctness of our implementation as thoroughly as possible. In addition to the provided programs we implemented a number of small tests ourselves to cover otherwised missed functionality.
An essential property of any system call is, that the system should never crash. Even if the user provided invalid arguments. The robustness of the system can be verified using `badcall` which tests for edge cases and `randcall` which calls random syscalls with random arguments. Even if some functions are not yet implemented, the kernel should never crash.
The first most basic test we performed was `palin` to show that `write` can properly print to stdout as this is essential for almost every other test. A slightly more complicated test we performed, is the `conman` test, which utilizes both stdin and stdout. Finally `bigseek` was the big test for our file syscalls. This program uses both console I/O as well as file I/O, and the `seek` syscall, covering almost all of the basic file syscalls. `close` and `dup2` were tested together in a simple self-written testcase `testclosedup`, as well as `__getcwd` and `chdir` in `testwdir`, rounding off our testing of the files syscalls.
To test execv we wrote a simple program `testexecv` which calls `argtest` with a specified set of arguments. `getpid`, `waitpid` and `fork` were finally all tested together by calling forktest. TODO: exit

## Bugs and TODOs

-----------
First, in order to support in a good manner file system calls, we created a new opt-file called `file_syscalls.c` that contains all the file-related system calls and some auxiliar functions that help the process. Inside the header file, we also defined a new structure called `fhandle` that works as a file table for our system where values `fid = 0`, `fid =1` and `fid=2`are destined to `stdin`, `stdout` and `stderr` respectively. As detailed more forward in this report, we defined the following system calls: `sys_open`, `sys_close`, `sys_read`, `sys_write`, `sys___getcwd`, `sys_chdir` and `sys_dup2`. [elaborate more]
Secondly, we implemented support for processes and their corresponding system calls, and for this part we created a new opt-file called `proc_syscalls.c` and defined new auxiliar methods to help the management of the new structure `pidhandle` defined in `proc.h`. Inside these files we have a simulation of a PID table that keeps the information about processes like exit status, running status and a list of process with their corresponding PID's, and as defined, `pid = 1 ` is reserved for the kernel process. For this part, we decided to keep also track of the children of processes. As written in the further sections, we defined the following system calls: `sys_getpid`, `sys_waitpid`, `sys_execv`, `sys_fork` and `sys_exit`. 
During this last part, we dealed with some issues respecting to fork and maintainence of process information when exiting a process after a fork failure, so we decided to define a new `option` called `OPT_FORK`, even though tests run with few errors. With respect to the other syscalls in the process side, they are working correctly and with some minor issues.
Lastly, we implemented synchronization for mainly obvious reasons such as synchronization when reading and writing. For this matter, we implemented locks and conditional variables using `waitchannels` and `spinlocks` that were already implemented in OS161. [maybe finish up with some conclusions]
--------------


